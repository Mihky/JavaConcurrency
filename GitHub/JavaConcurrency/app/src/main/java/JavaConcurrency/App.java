/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package JavaConcurrency;

import JavaConcurrency.signal.VotePoller;
import JavaConcurrency.thread_pool.ThreadPool;

import java.util.Random;

public class App {
    public static void main(String[] args) throws InterruptedException {
        ThreadPool threadPool = new ThreadPool(3, 10);
        threadPool.start();
        // handle like 1_000_000 tasks
        threadPool.shutdown();
    }

    private static Runnable getRunnable(Counter counterInterface, int counts) {
        return () -> {
            for (int i = 0; i < counts; i++) {
                counterInterface.incr();
            }
        };
    }

    // Create and start threads
    private static void example1() {
        for (int threadId = 0; threadId < 10; threadId++) {
            Thread thread = new Thread(new MyRunnable(), "" + threadId);
            System.out.println("Starting thread: " + thread.getName());
            thread.start();
        }
    }

    // Stop threads in a thread-safe way
    private static void example2() {
        DictatorRunnable dictatorRunnable = new DictatorRunnable();
        Thread dictatorThread = new Thread(dictatorRunnable, "dictator");
        dictatorThread.start();
        // let the dictatorThread run for 10 seconds
        try {
            Thread.sleep(3000);
        } catch (Exception ex) {}
        // Main thread will act as the hero and stop the dictatorThread
        dictatorRunnable.doStop();
    }

    // Race Conditions and how to safely deal with them using Counter example
    private static void example3() {
        BadCounter badCounter = new BadCounter();
        GoodCounter goodCounter = new GoodCounter();
        GoodCounter1 goodCounter1 = new GoodCounter1();
        int threads = 100;
        int counts = 1_000_000;
        for (int threadId = 0; threadId < threads; threadId++) {
            Thread thread = new Thread(getRunnable(badCounter, counts));
            thread.start();
            Thread safeThread = new Thread(getRunnable(goodCounter, counts));
            safeThread.start();
            Thread safeThread1 = new Thread(getRunnable(goodCounter1, counts));
            safeThread1.start();
        }
        System.out.println(String.format("%d threads each should count %d, expectedCount: %d", threads, counts, threads * counts));
        // let the counter threads enough time to increment
        try {
            Thread.sleep(10000);
        } catch (Exception ex) {}
        System.out.println(String.format("Final count using non-threadsafe count: %d", badCounter.getCount()));
        System.out.println(String.format("Final count using threadsafe count: %d", goodCounter.getCount()));
        System.out.println(String.format("Final count using threadsafe count using AtomicInteger: %d", goodCounter1.getCount()));
    }

    // Happens before guarantees
    // TODO Fix
    private static void example4() {
        HappensBeforeWriteRunnable1 runnable1 = new HappensBeforeWriteRunnable1();
        HappensBeforeWriteRunnable2 runnable2 = new HappensBeforeWriteRunnable2();

        Thread thread1 = new Thread(runnable1);
        Thread thread2 = new Thread(runnable1);
        thread1.start();
        thread2.start();

        Thread safeThread1 = new Thread(runnable2);
        Thread safeThread2 = new Thread(runnable2);
        safeThread1.start();
        safeThread2.start();
        try {
            Thread.sleep(15000);
        } catch (Exception ex) {}
        System.out.println(String.format("Position1=%d, Position2=%d", runnable1.getPosition1(), runnable1.getPosition2()));
        System.out.println(String.format("Position1=%d, Position2=%d", runnable2.getPosition1(), runnable2.getPosition2()));
    }

    // Signalling
    private static void example5() throws InterruptedException {
        int voters = 100;
        VotePoller runnable1 = new VotePoller(voters);
        Thread voteManagerThread = new Thread(runnable1);
        voteManagerThread.start();

        for (int i = 0; i < voters; i++) {
            int coinToss = (int) Math.round(Math.random());
            runnable1.vote(coinToss);
        }
        System.out.println("Waiting for vote results");
        Thread.sleep(10000);
        System.out.println(runnable1.getVotesA());
        System.out.println(runnable1.getVotesB());
    }
}
